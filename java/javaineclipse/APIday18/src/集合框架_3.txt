泛型：
   jdk1.5出现的安全机制。
   
好处：
   1.将运行时期的问题ClassCastException转到了编译时期。
   2.避免了强制转换的麻烦。
   
<>:什么时候用？当操作的引用数据类型不确定的时候。就使用<>.将要操作的引用数据类型传入即可  。
 其实<>就是一个用于接收具体引用数据类型的参数范围。
 
 在程序中，只要用到了带有<>的类或者接口，就要明确传入的具体引用数据类型。
 
 泛型技术是给编译器使用的技术，用于编译时期。确保里类型的安全。
 
 运行时，会将泛型去掉，生成的class文件中是不带泛型的。这个称为泛型的擦除。
 为什么擦除呢？为了兼容运行的类加载器。
 
 泛型的补偿：在运行时，通过获取元素色类型进行转换动作。不用使用者再强制转换了。
 
 
 泛型的通配符：
 
 ==================================================
 
 集合的一些技巧：
 
 需要唯一吗？
 需要：Set
    需要制定顺序：
                      需要：TreeSet
                   不需要：HashSet
                     但是想要一个和存储一致的顺序（有序）：LinkedHashSet
 不需要：List
    需要频繁增删吗？
    需要：LinkedList
   不需要：ArrayList
   
   如何记录每一个容器的结构和所属体系呢？
   
 看名字！
 
 List
     |--ArrayList
     |--LinkedList
     
 Set
     |--HashSet
     |--TreeSet
     
后缀名就是该集合所属的体系。

前缀名就是该集合的数据结构。

看到Array；就要想到数组，就要想到查询快，有角标。
看到Link：要想到链表，就要想到增删快，就要想到add get remove+first last的方法。
看到Hash：就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖Hashcode方法和Equals方法。
看到Tree：就要想到二叉树，就要想到排序，就要想到两个接口Comparable，Comparator。

而且通常这些常用的集合容器都是不同步的。

=================================================================

Map:一次添加一对元素。Collection一次添加一个元素。
    Map也称为双列集合，Collection集合称为单列集合。
             其实map集合中存储的就是键值对
    map集合中必须保证键的唯一性。
    
常用方法：
1.添加。
  value put(key,value):返回前一个和Key关联的值。如果没有返回null。
2.删除。
  void clear（）：清空Map集合。
  value remove（Key）：根据指定的Key翻出这个键值对。
3.判断。
   boolean containsKey(key);
   boolean containsValue(value);
   boolean isEmpty();
   
4.获取。
   value get(key):通过键获取值，如果没有该键返回null。
                  当然可以通过返回null，来判断是否包含指定键。
                  
   int size():获取键值对得个数。
   
   
   Map常用的字类:
      |--Hashtable:内部结构是哈希表，是同步的。
          |--Properties:用来存储键值对型的配置文件的信息，可以和IO技术相结合。
      |--HashMap:内部结构是哈希表，不是同步的。允许Null作为键，null作为值。
      |--TreeMap:内部结构是二叉树，不是同步的。可以对Map集合中德键进行排序。
   
